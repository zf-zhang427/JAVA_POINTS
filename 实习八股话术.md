第一章

```
在这个模块中，我设计了一个动态白名单机制，用于过滤 Kafka 中不需要处理的消息，将单条消息处理耗时从 3200ms 降到 19ms。

核心技术有三点：

第一，使用 CopyOnWriteArraySet 存储白名单。因为它读操作无锁，在每秒数万次 isFundAllowed() 判断的场景下性能极高。虽然写操作会复制数组，但由于配置变更极少，完全可以接受。

第二，提供 REST API 实现热更新。支持通过 POST /add 添加 ID。接口设计上考虑了幂等性（Set 自带去重）、安全性（JWT 认证、IP 白名单、限流）和操作审计，具备生产可用性。

第三，解决重启丢失问题。我们采用 Redis 持久化方案：启动时从 Redis 加载白名单到内存；运行时双写 Redis 和内存集合，保证多实例间状态一致。若 Redis 写入失败，则拒绝操作，防止状态不一致。

这套方案兼顾了性能、可用性和可维护性，后续也可平滑迁移到 Nacos 等配置中心。
```



前端到服务端

```sql
[用户]
  ↓ 输入 URL
[浏览器] → DNS 查询 → [DNS 服务器] → 返回 IP: 203.0.113.10
  ↓
[TCP 三次握手] → [TLS 握手] → 建立 HTTPS 安全连接
  ↓ HTTPS 请求
[Nginx] (反向代理)
  ↓ HTTP 转发 (proxy_pass)
[Tomcat] (Servlet 容器)
  ↓
[DispatcherServlet] (Spring MVC 前端控制器)
  ↓
[HandlerMapping] → 找到 @GetMapping("/order/{id}")
  ↓
[HandlerAdapter] → 调用 Controller 方法
  ↓
[OrderController] → orderService.findById(123)
  ↓
[Service] → [DAO] → [MySQL] → 返回订单数据
  ↓
[Controller] 返回 ModelAndView("order/detail", {order})
  ↓
[ViewResolver] → 解析为 /WEB-INF/views/order/detail.jsp
  ↓
[View] (JSP) → 渲染 HTML
  ↓
[Tomcat] → 返回 HTML 响应
  ↓
[Nginx] → 封装为 HTTPS 响应
  ↓
[浏览器] → 渲染页面 → 用户看到结果
```

