### 类加载？

Java 程序运行时，并不会一次性把所有类都加载到内存(方法区)，而是**在需要时才加载、链接、初始化类**。这个过程就是“类加载”。

#### 三个阶段

| 阶段                            | 作用                                                      |
| ------------------------------- | --------------------------------------------------------- |
| **1. 加载（Loading）**          | 找到 `.class` 文件，读入内存，生成 `java.lang.Class` 对象 |
| **2. 链接（Linking）**          | 验证、准备、解析                                          |
| **3. 初始化（Initialization）** | 执行类的静态代码（如 `static {}`、静态变量赋值）          |

#### 类加载器

 **双亲委派：**当一个类加载器收到加载请求，它**先委派给父类加载器**去完成，只有父类无法完成时，自己才尝试加载。

自定义类加载 -> 应用类加载 -> 扩展类加载 ->核心类加载

**好处：**

- 避免类的重复加载
- 保证核心类的安全性（不会被自定义类替换）



### ThreadLocal？

ThreadLocal 是一个类，用于**为每个线程提供一个独立的变量副本**，实现线程间的数据隔离。

#### 用途

| 场景                             | 说明                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| **1. 存储用户信息**              | 如在 Web 项目中，把当前登录用户存入 `ThreadLocal`，整个请求链路都能访问 |
| **2. 避免参数传递**              | 不用层层传参，直接通过 `ThreadLocal` 获取上下文              |
| **3. SimpleDateFormat 线程安全** | 每个线程有自己的副本，避免多线程下格式化出错                 |
| **4. 数据库连接管理**            | 如 MyBatis 的 `SqlSession` 绑定到当前线程                    |

#### 原理

- 每个线程（`Thread`）内部有一个 `ThreadLocalMap`
- `ThreadLocal` 作为 **key**，你存的数据是 **value**
- 调用 `threadLocal.set(x)` → 当前线程的 map 中存入 `<this, x>`
- 调用 `threadLocal.get()` → 从当前线程的 map 中取出 `this` 对应的值

#### 内存泄漏

- `ThreadLocalMap` 的 key 是 **弱引用**
- 但 value 是 **强引用**
- 如果不调用 `remove()`，当 `ThreadLocal` 被回收后，key 变成 null，但 value 还在，可能造成内存泄漏

方法：finally 手动清理



### AOP？

**把重复的、与业务无关的代码抽离出来**，在不修改原代码的情况下“动态织入”到目标方法的执行过程中。

| 概念                     | 说明                                                |
| ------------------------ | --------------------------------------------------- |
| **切面（Aspect）**       | 抽离出来的公共功能，比如“日志切面”                  |
| **连接点（Join Point）** | 方法执行的时机（Spring 中就是方法调用）             |
| **切入点（Pointcut）**   | 哪些方法要被增强（用表达式定义）                    |
| **通知（Advice）**       | 在目标方法的什么时机执行（前？后？异常？）          |
| **织入（Weaving）**      | 把切面应用到目标方法的过程（Spring 用动态代理实现） |

#### 底层原理

- **JDK 动态代理**：基于接口的代理（目标类实现了接口）
- **CGLIB 动态代理**：基于子类的代理（没有接口也能代理）

**AOP** 用于将日志、权限等横切逻辑与业务代码解耦，通过动态代理在方法执行前后插入逻辑。



### 事务？

要么全部成功，要么全部失败（ACID 特性）

A：原子性        C：一致性        I：隔离性        D：持久性

#### 事务核心注解：`@Transactional`

只要方法中抛出异常（非 `RuntimeException` 需配置），事务就会自动回滚。

#### 事务失效的常见原因

1. **方法不是 public** → `@Transactional` 失效
2. **自调用问题**：同一个类中，`A()` 调用 `B()`，`B` 有事务，但 `A` 没有 → 事务不生效
3. **异常被捕获但没抛出** → 事务不知道出错了，不会回滚

#### AOP 和事务

当你加上 `@Transactional`，Spring 会：

1. 创建一个代理对象
2. 在方法执行前：开启事务
3. 方法成功：提交事务
4. 方法异常：回滚事务

👉 本质上，`@Transactional` 就是一个 **AOP 切面**。























